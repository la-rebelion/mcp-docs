"use strict";(self.webpackChunkmcp_docs=self.webpackChunkmcp_docs||[]).push([[4420],{2206:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"components/hapi-server/openapi/schema-design","title":"Schema Design in HAPI Server: API-first, OpenAPI, and MCP","description":"Learn best practices for designing robust, maintainable schemas in HAPI server using OpenAPI and Model Context Protocol (MCP) principles.","source":"@site/docs/3-components/hapi-server/openapi/schema-design.md","sourceDirName":"3-components/hapi-server/openapi","slug":"/components/hapi-server/openapi/schema-design","permalink":"/components/hapi-server/openapi/schema-design","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"sidebar_label":"Schema Design","sidebar_class_name":"green","title":"Schema Design in HAPI Server: API-first, OpenAPI, and MCP","description":"Learn best practices for designing robust, maintainable schemas in HAPI server using OpenAPI and Model Context Protocol (MCP) principles.","keywords":["schema design","OpenAPI","MCP","HAPI server","API-first","validation","contract"],"author":"La Rebelion Labs","publisher":"MCP Project","dateModified":"2025-07-27"},"sidebar":"tutorialSidebar","previous":{"title":"OpenAPI Integration","permalink":"/components/hapi-server/openapi/"},"next":{"title":"Validation Layers","permalink":"/components/hapi-server/openapi/validation-layers"}}');var t=i(4848),o=i(8453);const r={sidebar_position:3,sidebar_label:"Schema Design",sidebar_class_name:"green",title:"Schema Design in HAPI Server: API-first, OpenAPI, and MCP",description:"Learn best practices for designing robust, maintainable schemas in HAPI server using OpenAPI and Model Context Protocol (MCP) principles.",keywords:["schema design","OpenAPI","MCP","HAPI server","API-first","validation","contract"],author:"La Rebelion Labs",publisher:"MCP Project",dateModified:"2025-07-27"},a="Schema Design: API-first, OpenAPI, and MCP",c={},d=[{value:"Principles of Good Schema Design",id:"principles-of-good-schema-design",level:2},{value:"Example: User Schema",id:"example-user-schema",level:2},{value:"Using Enums and Constraints",id:"using-enums-and-constraints",level:2},{value:"<code>oneOf</code>, What is it? When and How to use it?",id:"oneof-what-is-it-when-and-how-to-use-it",level:2},{value:"Approaches for Handling <code>oneOf</code> Schemas in MCP Input Generation",id:"approaches-for-handling-oneof-schemas-in-mcp-input-generation",level:3},{value:"Tool Definition example",id:"tool-definition-example",level:4},{value:"Best Practices",id:"best-practices",level:2},{value:"Further Reading",id:"further-reading",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"schema-design-api-first-openapi-and-mcp",children:"Schema Design: API-first, OpenAPI, and MCP"})}),"\n",(0,t.jsx)(n.p,{children:"Schema design is the foundation of any API-first system. In HAPI, your OpenAPI schema defines not just endpoints, but also the structure, validation, and semantics of every request and response."}),"\n",(0,t.jsx)(n.h2,{id:"principles-of-good-schema-design",children:"Principles of Good Schema Design"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Explicitness:"})," Define all fields, types, and constraints clearly."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Validation:"})," Use OpenAPI's built-in validation keywords (",(0,t.jsx)(n.code,{children:"type"}),", ",(0,t.jsx)(n.code,{children:"format"}),", ",(0,t.jsx)(n.code,{children:"enum"}),", ",(0,t.jsx)(n.code,{children:"pattern"}),", etc.)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Reusability:"})," Use ",(0,t.jsx)(n.code,{children:"$ref"})," and ",(0,t.jsx)(n.code,{children:"components/schemas"})," to avoid duplication."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Extensibility:"})," Leverage OpenAPI extensions (e.g., ",(0,t.jsx)(n.code,{children:"x-hapi"}),") for MCP-specific needs."]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Design your schemas with future agents and tools in mind. Well-structured schemas make it easier for MCP-powered agents to reason about and use your API."})}),"\n",(0,t.jsx)(n.h2,{id:"example-user-schema",children:"Example: User Schema"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"components:\n  schemas:\n    User:\n      type: object\n      required:\n        - id\n        - name\n      properties:\n        id:\n          type: string\n        name:\n          type: string\n        email:\n          type: string\n          format: email\n        roles:\n          type: array\n          items:\n            type: string\n"})}),"\n",(0,t.jsx)(n.h2,{id:"using-enums-and-constraints",children:"Using Enums and Constraints"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"components:\n  schemas:\n    Status:\n      type: string\n      enum: [active, inactive, pending]\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"caution",children:(0,t.jsxs)(n.p,{children:["Avoid using overly generic types (like ",(0,t.jsx)(n.code,{children:"object"}),"). This can make validation and documentation less effective."]})}),"\n",(0,t.jsxs)(n.h2,{id:"oneof-what-is-it-when-and-how-to-use-it",children:[(0,t.jsx)(n.code,{children:"oneOf"}),", What is it? When and How to use it?"]}),"\n",(0,t.jsxs)(n.p,{children:["JSON Schema is a powerful tool for validating complex data structures. The ",(0,t.jsx)(n.a,{href:"https://swagger.io/docs/specification/v3_0/data-models/oneof-anyof-allof-not/#oneof",children:(0,t.jsx)(n.code,{children:"oneOf"})})," keyword allows you to specify that a value must match exactly one of the given schemas, ",(0,t.jsx)(n.strong,{children:"valid against exactly one"})," (XOR) of the subschemas."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'components:\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: string\n        type:\n          oneOf:\n            - const: "admin"\n            - const: "user"\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When you design your schemas, consider how they will be used by both humans and machines. Clear, concise schemas improve developer experience and reduce errors. For instance, if your API defines a ",(0,t.jsx)(n.code,{children:"path"})," parameter that can accept multiple types, using ",(0,t.jsx)(n.a,{href:"https://json-schema.org/understanding-json-schema/reference/combining#anyOf",children:(0,t.jsx)(n.code,{children:"oneOf"})})," can make this explicit. Unfortunately, in the MCP context, the use of ",(0,t.jsx)(n.code,{children:"oneOf"})," can be limited by the need for more specific type information, agents (human-like) need to understand the context better."]}),"\n",(0,t.jsxs)(n.h3,{id:"approaches-for-handling-oneof-schemas-in-mcp-input-generation",children:["Approaches for Handling ",(0,t.jsx)(n.code,{children:"oneOf"})," Schemas in MCP Input Generation"]}),"\n",(0,t.jsxs)(n.p,{children:["When creating JSON schemas for tools in the Model Context Protocol (MCP), using the ",(0,t.jsx)(n.code,{children:"oneOf"})," keyword can be challenging. If your API needs to accept different object types in the ",(0,t.jsx)(n.code,{children:"requestBody"}),", ",(0,t.jsx)(n.code,{children:"oneOf"})," helps you list all allowed types. However, you must define every possible type in advance, both on the client and server sides. At runtime, choosing the correct type can be difficult."]}),"\n",(0,t.jsx)(n.p,{children:"In the HAPI Server, we solved this by combining client-side type hints with server-side validation. Here are the options we considered:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Use a Discriminator Property"}),"\n",(0,t.jsx)(n.li,{children:"Generate Separate Tool Definitions"}),"\n",(0,t.jsx)(n.li,{children:"Merge All Properties into One Schema"}),"\n",(0,t.jsx)(n.li,{children:"Resolve Schemas Dynamically"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["We chose ",(0,t.jsx)(n.strong,{children:"option 2: Generate Separate Tool Definitions"})," because:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"It does not change the original schema."}),"\n",(0,t.jsx)(n.li,{children:"API consumers do not need to make any changes."}),"\n",(0,t.jsx)(n.li,{children:"It keeps each type exclusive, so invalid combinations are avoided."}),"\n",(0,t.jsx)(n.li,{children:"It allows tools to be created as needed, making the system flexible."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This approach makes it easier for both humans and machines to work with the API, and helps prevent errors."}),"\n",(0,t.jsx)(n.h4,{id:"tool-definition-example",children:"Tool Definition example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"# ... remove other methods for simplicity\n    post:\n      # ... removed content for simplicity\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              oneOf:        # <-- This indicates that the request body must match exactly one of the specified schemas\n                - title: 'Person'\n                  properties:\n                    name:\n                      type: string\n                    age:\n                      type: integer\n                - title: 'Company'\n                  properties:\n                    name:\n                      type: string\n                    registrationNumber:\n                      type: string\n                      format: uuid\n# ... removed content for simplicity\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"oneOf"})," construct is used to define two possible schemas for the request body: one for a ",(0,t.jsx)(n.code,{children:"Person"})," and another for a ",(0,t.jsx)(n.code,{children:"Company"}),". This creates separate tool definitions for each schema variant:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Tool 1: createPerson\nTool 2: createCompany\n"})}),"\n",(0,t.jsx)(n.p,{children:"Each with its own schema definition, instead of trying to represent a union type."}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"$ref"})," to share common models across endpoints."]}),"\n",(0,t.jsx)(n.li,{children:"Document all fields, even optional ones."}),"\n",(0,t.jsxs)(n.li,{children:["Use OpenAPI's ",(0,t.jsx)(n.code,{children:"description"})," fields for clarity."]}),"\n",(0,t.jsx)(n.li,{children:"Validate with tools like Swagger Editor or openapi-generator."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://swagger.io/specification/#schema-object",children:"OpenAPI Schema Object"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/la-rebelion/hapi-mcp",children:"HAPI MCP source code"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/la-rebelion",children:"Model Context Protocol (MCP)"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);