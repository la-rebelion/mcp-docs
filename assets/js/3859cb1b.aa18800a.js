"use strict";(self.webpackChunkmcp_docs=self.webpackChunkmcp_docs||[]).push([[9082],{8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var s=t(6540);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}},9202:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"troubleshooting/known-issues","title":"Known Issues: MCP, OpenAPI, API-first","description":"List of known issues with MCP, OpenAPI, and API-first workflows.","source":"@site/docs/troubleshooting/known-issues.md","sourceDirName":"troubleshooting","slug":"/troubleshooting/known-issues","permalink":"/troubleshooting/known-issues","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"sidebar_label":"Known Issues"},"sidebar":"tutorialSidebar","previous":{"title":"Deployment Guide","permalink":"/deployment/"},"next":{"title":"Developer Experience","permalink":"/devex/"}}');var i=t(4848),r=t(8453);const a={sidebar_position:1,sidebar_label:"Known Issues"},o="Known Issues: MCP, OpenAPI, API-first",c={},d=[{value:"OpenAPI Path Parameter Naming Conflicts",id:"openapi-path-parameter-naming-conflicts",level:2},{value:"Failed to start server: Cannot create route &quot;<code>/test/{name}/sub</code>&quot; with parameter &quot;<code>name</code>&quot; because a route already exists with a different parameter name (&quot;<code>id</code>&quot;) in the same location.",id:"failed-to-start-server-cannot-create-route-testnamesub-with-parameter-name-because-a-route-already-exists-with-a-different-parameter-name-id-in-the-same-location",level:3},{value:"Conclusion",id:"conclusion",level:3}];function l(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"known-issues-mcp-openapi-api-first",children:"Known Issues: MCP, OpenAPI, API-first"})}),"\n",(0,i.jsx)(n.p,{children:"List of known issues with MCP, OpenAPI, and API-first workflows."}),"\n",(0,i.jsxs)(n.p,{children:["This document is a living document and will be updated as new issues are discovered and resolved. Not all issues may have a workaround or solution, and some issues may be specific to the ",(0,i.jsx)(n.strong,{children:"API design"})," or implementation, not MCP or HAPI itself."]}),"\n",(0,i.jsx)(n.h2,{id:"openapi-path-parameter-naming-conflicts",children:"OpenAPI Path Parameter Naming Conflicts"}),"\n",(0,i.jsx)(n.p,{children:"When defining paths in an OpenAPI specification, it's crucial to ensure that path parameters are named consistently to avoid conflicts. A common issue arises when two paths have the same structure but use different parameter names, leading to ambiguity and errors during server startup."}),"\n",(0,i.jsxs)(n.h3,{id:"failed-to-start-server-cannot-create-route-testnamesub-with-parameter-name-because-a-route-already-exists-with-a-different-parameter-name-id-in-the-same-location",children:['Failed to start server: Cannot create route "',(0,i.jsx)(n.code,{children:"/test/{name}/sub"}),'" with parameter "',(0,i.jsx)(n.code,{children:"name"}),'" because a route already exists with a different parameter name ("',(0,i.jsx)(n.code,{children:"id"}),'") in the same location.']}),"\n",(0,i.jsxs)(n.p,{children:["Based on the ",(0,i.jsx)(n.a,{href:"https://swagger.io/specification/#path-templating-matching",children:"OpenAPI specification"}),", this is an invalid OpenAPI definition because the paths are considered identical due to their structure, despite having different parameter names."]}),"\n",(0,i.jsx)(n.p,{children:"The Issue with this API Design is that there are two paths that could potentially cause conflicts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/test/{name}/sub"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.code,{children:"/test/{id}"})}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Recommendations"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use Consistent Parameter Names",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Best practice:"})," Use the same parameter name for the same semantic entity across all paths."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"# Good practice\n/test/{id}\n/test/{id}/sub\n"})}),"\n",(0,i.jsx)(n.p,{children:"This makes it clear that you're dealing with the same type of resource identifier in both paths."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Differentiate Path Structures",(0,i.jsx)(n.br,{}),"\n","If you truly need to access resources by different identifiers, make the paths structurally different:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"/test/by-id/{id}\n/test/by-name/{name}/sub\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Use Query Parameters Instead",(0,i.jsx)(n.br,{}),"\n","For alternative ways to identify a resource, consider using query parameters:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"/test?id={id}\n/test?name={name}\n# OR\n/test/{id}              # Access by ID\n/test?name={name}       # Access by name\n"})}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Add Resource Type Prefixes"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"/test/user/{id}\n/test/product/{id}/sub\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Implementation Considerations"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Don't rely on backend validation alone:"})," While you could theoretically handle name vs. ID validation in your code, the OpenAPI specification won't properly document this distinction, leading to potential confusion and routing issues."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Resource identification:"})," If you need to support multiple ways to identify the same resource (ID, name, email, etc.), use the query parameter approach or create distinct path structures."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"API consistency:"})," Whatever approach you choose, be consistent throughout your API design to make it intuitive for developers to use."]}),"\n",(0,i.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The most straightforward solution is to use consistent parameter names when referring to the same type of entity, and to create structurally distinct paths when dealing with different types of resources or identification methods."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);